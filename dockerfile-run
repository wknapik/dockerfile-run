#!/usr/bin/env bash
# Execute dockerfiles as scripts.
# https://github.com/wknapik/dockerfile-run
# Requirementes: bash, coreutils, curl (optional), docker, ncurses (optional).

## FIXME: include in tests.
# Environment variables:
#
# DFR_CONTEXT: build context
#     default when reading from local file: <directory containing dockerfile>
#     default when reading from stdin or remote file: <current directory>
# DFR_VERBOSITY: 0 - no output; 1 - condensed output; 2 - full output
#     default: 1

# Fail on any error.
shopt -s inherit_errexit
set -eEo pipefail

# Fail with a message.
error() { echo "$*" >&2; exit 2; }

# `docker run' options can be passed via shebang and/or command line, followed
# by a delimeter each time.
parse_args() {
    local delim="---"
    local idxs=() # array indexes of delimeters
    for ((i=1; i <= $#; ++i)); do
        [[ "${*:$i:1}" != "$delim" ]] || idxs+=("$i")
    done
    case "${#idxs[@]}" in
        0) args=("$@");;
        1) docker_run_opts_cmd=("${@:1:${idxs[0]}-1}")
           args=("${@:${idxs[0]}+1}");;
        *) docker_run_opts_cmd=("${@:1:${idxs[0]}-1}")
           args=("${@:${idxs[0]}+1:1}")
           docker_run_opts_cmd+=("${@:${idxs[0]}+2:${idxs[1]}-${idxs[0]}-2}")
           args+=("${@:${idxs[1]}+1}");;
    esac
}
parse_args "$@"

# Do different things depending on the location of the Dockerfile (stdin,
# https(s), or local file).
case "${args[0],,}" in
    # For stdin and http(s), create a temporary Dockerfile. Build context is
    # $PWD, unless overridden.
    -|http://*|https://*)
       trap 'rm -f "$dockerfile_path"' EXIT
       dockerfile_path="$(umask 0177; mktemp --suffix=-stdin-or-remote)"
       if [[ "${args[0]}" == - ]]; then cat; else curl -fsSL "${args[0]}"; fi >"${dockerfile_path:?}"
       build_context="${DFR_CONTEXT:-"$PWD"}";;

    # For local Dockerfiles, build context is the directory containing the
    # Dockefile, unless overridden.
    *) dockerfile_path="$(realpath "${args[0]:?}")"
       build_context="${DFR_CONTEXT:-"$(dirname "$dockerfile_path")"}";;
esac

# Set command-line options for `docker run':
# * `--rm --init' are passed unconditionally
# * `-it' is passed when stdin refers to a terminal
# * additional options can be passed (see: above)
docker_run_opts=(--rm --init "${docker_run_opts_cmd[@]}")
[[ ! -t 0 ]] || docker_run_opts+=(-it)

# Generate a build tag for the image.
dockerfile_path_sanitized="${dockerfile_path//[^[:alnum:]]/-}"
dockerfile_path_id="$(md5sum <<<"${dockerfile_path:?}"|cut -d' ' -f1)"
build_tag="dockerfilerun-${dockerfile_path_sanitized,,}-${dockerfile_path_id:?}"

# Show progress while building an image.
[[ ! -t 1 ]] || trap 'tput cnorm' EXIT
progress() {
    # 0 - no output; 1 - condensed output; 2 - full output.
    case "${DFR_VERBOSITY:-1}" in
        0) cat >/dev/null;;
        1) if [[ -t 1 ]]; then
               local j=0 spinner=(- \\ "|" /)
               tput civis 2>/dev/null || true
               while read -r _; do
                   printf "%s\r" "${spinner[((++j % 4))]}"
               done >&2
               tput cnorm 2>/dev/null || true
           else
               while read -r _; do echo -n .; done >&2
               echo . >&2
           fi;;
        2) cat;;
        *) error "Invalid verbosity level. Valid values are 0, 1 and 2."
    esac
}

# Build the image.
docker build --label dockerfile-run -t "${build_tag:?}" -f "$dockerfile_path" "${build_context:?}"|progress

# Execute the supplied command, or the default CMD.
exec docker run "${docker_run_opts[@]}" "$build_tag" "${args[@]:1}"
