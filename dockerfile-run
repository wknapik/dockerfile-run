#!/usr/bin/env bash
# Execute dockerfiles as scripts.

## FIXME: include those in tests.
# DFR_CONTEXT: build context
#     default when reading from local file: <directory containing dockerfile>
#     default when reading from stdin or remote file: <current directory>
# DFR_OPTS: docker run options
#     default for stdin w/ tty: --rm -it --init
#     default otherwise: --rm --init
# DFR_QUIET: drop stdout from `docker build'
#     default: 1

# Fail on any error.
shopt -s inherit_errexit
set -eEo pipefail

# Do different things depending on the location of the Dockerfile (stdin,
# https(s), or local file).
case "${1,,}" in
    # For stdin and http(s), create a temporary Dockerfile. Build context is
    # $PWD, unless overridden.
    -|http://*|https://*)
       trap 'rm -f "$dockerfile_path"' EXIT
       dockerfile_path="$(umask 0177; mktemp --suffix=-stdin-or-remote)"
       if [[ "$1" == - ]]; then cat; else curl -fsSL "$1"; fi >"${dockerfile_path:?}"
       build_context="${DFR_CONTEXT:-"$PWD"}";;

    # For local Dockerfiles, build context is the directory containing the
    # Dockefile, unless overridden.
    *) dockerfile_path="$(realpath "$1")"
       build_context="${DFR_CONTEXT:-"$(dirname "$dockerfile_path")"}";;
esac

# Set command-line options for `docker run'.
[[ ! -t 0 ]] || add_opts=(-it)
read -ra run_opts <<<"${DFR_OPTS:---rm --init "${add_opts[@]}"}"

# Generate a build tag for the image.
dockerfile_path_sanitized="${dockerfile_path//[^[:alnum:]]/-}"
dockerfile_path_id="$(md5sum <<<"${dockerfile_path:?}"|cut -d' ' -f1)"
build_tag="dockerfilerun-${dockerfile_path_sanitized,,}-${dockerfile_path_id:?}"

# Discard stdout from `docker build', unless overridden.
# shellcheck disable=SC2015
[[ "${DFR_QUIET:-1}" == 1 ]] && exec 6>/dev/null || exec 6>&1

# Build the image.
docker build --label dockerfile-run -t "${build_tag:?}" -f "$dockerfile_path" "${build_context:?}" >&6

# Execute the supplied command, or the default CMD.
shift
docker run "${run_opts[@]}" "$build_tag" "$@"
